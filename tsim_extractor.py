from enum import Enum
import argparse
import sys
from io import TextIOWrapper
from typing import NoReturn
from pathlib import Path

class ObjectType(Enum):
    SENSOR = 1
    SWITCH = 2

ObjectData = tuple[ObjectType, int, int]

def fatal(msg: str, line: str | None, code: int) -> NoReturn:
    print(f"tsim_extractor: {msg}", file=sys.stderr)
    if line:
        print(f"-> {line}", file=sys.stderr)
    sys.exit(code)

def parse_file(file: TextIOWrapper) -> list[ObjectData]:
    result: list[ObjectData] = []

    for line_count, line in enumerate(file, start=1):
        segs = line.split()
        if "R" not in segs:
            continue

        x: int
        y: int

        if len(segs) < 6:
            if "Custom" in segs:
                continue; 

            fatal(f"line {line_count}: Not enough values to be Rail", line, 1)

        try:
            x = int(segs[1])
        except ValueError:
            fatal(f"line {line_count}: Could not parse x-value: {segs[1]} as int", line, 1)

        try:
            y = int(segs[2])
        except ValueError:
            fatal(f"line {line_count}: Could not parse y-value: {segs[2]} as int", line, 1)

        try:
            if int(segs[3]) == 2:
                rails = [segs[4], segs[5]]
                if not ("HorizontalRail" in rails and "VerticalRail" in rails):
                    result.append((ObjectType.SWITCH, x, y)) 
        except ValueError:
            print(f"tsim_extractor: line {line_count}: Could not parse rail count: {segs[3]}", file=sys.stderr)
            print(f"-> {line}", file=sys.stderr)

        # Must trim last since it has eol
        last = segs[-1].strip()

        if "Sensor" == last:
            result.append((ObjectType.SENSOR, x, y))
        elif "NoSensor" != last: 
            print(f"tsim_extractor: line {line_count}: Unknown sensor-enum: {last}", file=sys.stderr)
            print(f"-> {line}", file=sys.stderr)

    return result

def print_output_file(args: argparse.Namespace, data: list[ObjectData]):
    if not data:
        print("tsim_extractor: nothing to print to output file! (file without sensors or switches?).")
        sys.exit(0)

    switches = [ switch for switch in data if switch[0] == ObjectType.SWITCH ]
    sensors = [ sensor for sensor in data if sensor[0] == ObjectType.SENSOR ]

    out_path = Path(args.output_file)

    out_path.parent.mkdir(parents=True, exist_ok=True)

    with out_path.open("w") as file:
        file.write("// ---------------------------------- GENERATED BY TSIM_EXTRACTOR -------------------------------------\n")
        file.write("\n")
        if switches:
            file.write("// Switches \n")
            file.write("\n")

            for i, (_, x, y) in enumerate(switches):
                file.write(f"{args.switch_name} tswitch_{i} = new {args.switch_name}({x}, {y}); \n")

            file.write("\n")

        if sensors:
            file.write("// SENSORS \n")
            file.write("\n")

            for i, (_, x, y) in enumerate(sensors):
                file.write(f"{args.sensor_name} tsensor_{i} = new {args.sensor_name}({x}, {y}); \n")

            file.write("\n")
        
        file.write("// Array loading")
        file.write("\n")

        for i, (_, x, y) in enumerate(switches):
            file.write(f"{args.switch_list_name}.{args.list_push_name}(tswitch_{i});\n")

        file.write("\n")

        for i, (_, x, y) in enumerate(sensors):
            file.write(f"{args.sensor_list_name}.{args.list_push_name}(tsensor_{i});\n")

        file.write("\n")
        file.write("// ------------------------ made by William Lindgren ~ Duplo ~ github.com/Toireosu --------------------\n");



def create_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(
        prog="tsim_extractor",
        description="Converts a TSim map to Java source code."
    )

    parser.add_argument("input_file", metavar="INPUT_FILE",
                        help="tsim map data input file")
    parser.add_argument("--output_file",
                        help="output .java file to write to",
                        default="results/data.java")
    parser.add_argument("--sensor_name",
                        help="name in Java file for sensor class",
                        default="Sensor")
    parser.add_argument("--switch_name",
                        help="name in Java file for switch class",
                        default="Switch")
    parser.add_argument("--sensor_list_name",
                        help="name in Java file for sensor list",
                        default="sensors")
    parser.add_argument("--switch_list_name",
                       help="name in Java file for switch list",
                       default="switches")
    parser.add_argument("--list_push_name",
                       help="name in Java file for 'push'/'append'/'add' function on list",
                       default="add")

    parser.add_argument(
        "-V", "--version",
        action="version",
        version="tsim_extractor 1.0"
    )

    return parser

def main():
    parser = create_parser()

    args = parser.parse_args()

    input_data: list[ObjectData]
    with open(args.input_file, mode="r") as input_file:
        input_data = parse_file(input_file)

    print_output_file(args, input_data)

    print("Jobs done :3")
    print(f"Printed to {args.output_file}!")

if __name__ == "__main__":
    main()